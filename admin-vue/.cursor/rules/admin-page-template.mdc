---
description: 
globs: 
alwaysApply: false
---
# Standard Page Template Rules for Admin System

## Project Directory Structure Explanation
```
src/
# Standard Page Template Rules for Admin System

## Project Directory Structure Explanation
```
src/
  ├── components/         # 组件目录
  │   └── ProComponent/   # Pro系列组件
  ├── utils/proApi/    # API接口目录
  │   ├── admin.ts        # 后台管理接口
  │   └── types/            # 类型定义目录
  │       └── adminTypes.ts # 后台管理接口类型定义
  └── views/              # 页面目录
      └── [模块名称]/      # 具体业务模块目录
```

## API Interface Explanation
All interface functions are located in `@/utils/proApi/admin.ts`, automatically generated by the `scripts/tsapi.js` script.

## Type Definition Explanation
All type definitions are located in `@/utils/proApi/types/xxxTypes.ts`, automatically generated by the `scripts/tsapi.js` script.

## CRUD Directory Structure Specification

When creating a basic CRUD page, the following directory structure should be followed:

```
页面目录/
  ├── index.vue          # 页面主文件
  └── config/            # 配置文件目录
      └── column.ts      # 表格和表单配置文件
```

## Form Validation Rule Writing Specification

### Simplified Configuration for `required` Rule
When `required` is set to true, only configure the `required` and `trigger` attributes. There is no need to manually specify the `message` attribute. The system will automatically generate an error prompt message.

```typescript
// ✅ 推荐: 简化的规则写法
rules: [{ required: true, trigger: 'blur' }]

// ❌ 不推荐: 冗余的规则写法
rules: [{ required: true, message: '请输入xxx', trigger: 'blur' }]
```

### Validation Trigger Timing Selection
- For input boxes, text areas, etc., use `'blur'` to trigger validation.
- For select boxes, radio buttons, checkboxes, upload components, etc., use `'change'` to trigger validation.

```typescript
// 输入框
{
  label: '字段名称',
  prop: 'fieldName',
  valueType: 'input',
  rules: [{ required: true, trigger: 'blur' }]
}

// 选择框
{
  label: '字段名称',
  prop: 'fieldName',
  valueType: 'select',
  rules: [{ required: true, trigger: 'change' }]
}
```

### Complex Validation Rules
When custom validation logic or error messages are needed, the full rule configuration can still be used:

```typescript
rules: [
  { required: true, trigger: 'blur' },
  { min: 3, max: 20, message: '长度在3到20个字符之间', trigger: 'blur' },
  { pattern: /^[A-Za-z0-9]+$/, message: '只能包含字母和数字', trigger: 'blur' }
]
```

### Custom Validator
When using a custom validator, an error message must be specified:

```typescript
rules: [
  { required: true, trigger: 'blur' },
  {
    validator: (rule, value, callback) => {
      if (value && value.length < 6) {
        callback(new Error('长度不能小于6个字符'))
      } else {
        callback()
      }
    },
    trigger: 'blur'
  }
]
```

## File Content Specification

### config/column.ts

```typescript
import type { ProFormColumn, ProTableColumn } from '@/components/ProComponent'
// 导入对应的接口类型定义
import type { YourModuleVO, YourModuleForm } from '@/utils/proApi/types/adminTypes'

// 表格列配置
// 使用从 types/adminTypes.ts 中找到的列表类型 YourModuleVO
export const tableColumns: ProTableColumn<YourModuleVO>[] = [
  // 基础字段配置
  { label: 'ID', prop: 'id', width: 50 },
  // 根据 YourModuleVO 类型定义配置其他业务字段...
]

// 表单配置
// 使用从 types/adminTypes.ts 中找到的表单类型 YourModuleForm
export const formColumns: ProFormColumn<YourModuleForm>[] = [
  { label: 'ID', prop: 'id', hidden: true },
  // 根据 YourModuleForm 类型定义配置其他表单字段...
]
```

### index.vue

```vue
<script setup lang="ts">
import { ref } from 'vue'
import { ElMessage } from 'element-plus'
import { formColumns, tableColumns } from './config/column'
import type { ProTableColumn } from '@/components/ProComponent'
import { ProTable, ProForm } from '@/components/ProComponent'
// [模块名称] will be used in API calls as per the original Chinese template
import { deleteApiV1[模块名称]Byids, getApiV1[模块名称]Page, postApiV1[模块名称], putApiV1[模块名称]Byid } from '@/utils/proApi/admin'

// 工具栏配置
const toolbar = [
  {
    name: 'add',
    text: '新增', // Kept Chinese
    type: 'success',
    onClick: handleAddClick,
  },
]

// 表格列配置
const cols: ProTableColumn<T>[] = [
  ...tableColumns,
  {
    label: '操作', // Kept Chinese
    fixed: 'right',
    width: 80,
    valueType: 'tool',
    operat: [
      {
        name: 'edit',
        text: '编辑', // Kept Chinese
        onClick: handleEditClick,
      },
      {
        name: 'delete',
        text: '删除', // Kept Chinese
        onClick: handleDeleteClick,
      },
    ],
  },
]

const tableRef = ref()
const formRef = ref()
const open = ref(false)

// CRUD 操作处理
async function handleEditClick(row: T) {
  open.value = true
  formRef.value?.setFormData(row)
}

async function handleDeleteClick(ids: string) {
  await deleteApiV1[模块名称]Byids({ ids })
  ElMessage.success('删除成功') // Kept Chinese
  tableRef.value?.fetchPageData()
}

function handleAddClick() {
  formRef.value?.resetFormData()
  open.value = true
}

async function onSubmit(data: T) {
  if (data.id)
    await putApiV1[模块名称]Byid({ id: data.id }, data)
  else
    await postApiV1[模块名称](data) // Removed "mdc:" as it was likely a typo in original

  open.value = false
  ElMessage.success('操作成功') // Kept Chinese
  tableRef.value?.fetchPageData()
}

function getList(params: any) {
  return getApiV1[模块名称]Page(params)
}
</script>

<template>
  <div class="app-container">
    <ProTable
      ref="tableRef"
      :columns="cols"
      :toolbar="toolbar"
      :request="getList"
      :search="false"
    />

    <ProForm
      ref="formRef"
      v-model:open="open"
      type="drawer"
      :drawer-props="{ title: '表单标题' }" // Kept Chinese
      :columns="formColumns"
      :on-submit="onSubmit"
    >
      <!-- 自定义插槽 -->
      <template #customSlotName="scope">
        <!-- 
          scope包含以下属性：
          - formData: 整个表单数据对象
          - prop: 当前表单项的属性名
          - disabled: 表单项是否禁用
        -->
        <el-component v-model="scope.formData[scope.prop]" />
        
        <!-- 或者对于需要类型转换的情况 -->
        <el-component
          :model-value="convertValueForDisplay(scope.formData[scope.prop])"
          @update:model-value="val => scope.formData[scope.prop] = convertValueForStorage(val)"
        />
      </template>
    </ProForm>
  </div>
</template>
```

## List Page Specification

### Action Column Configuration Specification
- **Action Column Width**: The width of the action column for all pages is uniformly set to 80 to ensure consistent page style.
- **Action Column Position**: The action column should be fixed on the right (via the `fixed: 'right'` attribute) for user convenience.
- **Action Column Buttons**: Set edit, delete, and other action buttons as needed, maintaining consistency in naming and icons (button text itself in Chinese as per code examples).

### Time Column Configuration Specification
- **Time Column Width**: The width of all time-related columns (such as creation time, update time, validity period, etc., which may be in year-month-day-hour-minute-second format) is uniformly set to 160 to ensure enough space to display complete time information.
- **Time Formatting**: It is recommended to format the time display according to actual needs; `formatFn` can be used for custom formatting.

## Usage Instructions

### 1. Page Structure
- Use the ProTable component to implement data table display.
- Use the ProForm component to implement form operations.
- Integrate basic CRUD functionalities.

### 2. Configuration File

#### tableColumns: Define table display fields
- **Basic Attributes**:
  - `label`: Column title (descriptive, can be English)
  - `prop`: Field name
  - `width`: Column width
  - `type`: Column type, options: 'default' | 'selection' | 'index' | 'expand'
  - `columnKey`: Column key value
  - `showOverflowTooltip`: Whether to show overflow tooltip

- **Display Control**:
  - `hideInSearch`: Whether to hide in the search form
  - `hideInTable`: Whether to hide in the table

- **Data Display**:
  - `valueType`: Display type, supports 'image' | 'select' | 'url' | 'switch' | 'input' | 'price' | 'percent' | 'icon' | 'date' | 'tool' | 'custom' | 'date-picker'
  - `valueEnum`: Option data, format: `{ value: any, label: string, tagType?: 'primary' | 'success' | 'info' | 'warning' | 'danger' }[]` (labels here are for UI, so should remain Chinese if that's the project language)
    Example: `{ label: '启用', value: 1, tagType: 'success' }`

- **Formatting**:
  - `formatFn`: `(val: any, allData: T) => string`, custom formatting function

- **Interaction**:
  - `onClick`: `(params: T) => void`, click event handler
  - `operat`: Action button configuration, supports array or function form (button text like '编辑', '删除' should remain Chinese)

- **Image Related**:
  - `imageWidth`: Image width
  - `imageHeight`: Image height

- **Filter Related**:
  - `filterJoin`: Filter value joiner

- **Initialization**:
  - `initFn`: `(item: ProTableColumn<T>) => void`, initialization data function

#### formColumns: Define form fields
- **Basic Attributes**:
  - `label`: Label text (descriptive, can be English for the rule, but in code means UI label - keep Chinese if UI is Chinese e.g. `label: '字段名称'`)
  - `prop`: Field name
  - `tips`: Tip information (descriptive, can be English for the rule)
  - `key`: Unique identifier
  - `addonAfter`: Suffix text

- **Component Type**:
  - `valueType`: Component type, supports 'input' | 'select' | 'radio' | 'checkbox' | 'tree-select' | 'date-picker' | 'time-picker' | 'input-number' | 'text' | 'upload' | 'formList' | 'custom' | 'cascader' | 'group'

- **Component Attributes**:
  - `attrs`: Corresponds to different ElementPlus component attributes based on valueType
  - `formTtemAttrs`: ElFormItem component attributes

- **Data Configuration**:
  - `valueEnum`: Option data, format: `{ value: any, label: string, tagType?: string }[]` (UI labels - keep Chinese)
  - `initialValue`: Initial value
  - `slotName`: Custom slot name (used when valueType is 'custom')

- **Validation Rules**:
  - `rules`: ElementPlus FormItemRule[] type validation rules (messages like '请输入xxx' should remain Chinese)
  - When `required` is true, only configure `required` and `trigger` attributes, no need to manually specify the `message` attribute (system generates Chinese message).

- **Display Control**:
  - `hidden`: Whether to hide (similar to v-show)
  - `unMounted`: Whether to unmount (similar to v-if)

- **Data Processing**:
  - `transform`: `(value: any, itemConfig: ProFormColumn<T>) => any`, transformation function when getting form values
  - `convertValue`: `(value: any, alldata: T) => any`, transformation function when setting form values

- **Listener Handling**:
  - `watch`: `(newValue: any, oldValue: any, data: T, items: ProFormColumn<T>[], formItemTool: IObject) => void`, watch function
  - `computed`: `(data: T) => any`, computed property function

- **Sub-form**:
  - `columns`: Sub-form configuration, used for nested form scenarios

- **Initialization**:
  - `initFn`: `(item: ProFormColumn<T>) => void`, initialization data function

### 3. Data Interaction
- Use auto-generated API functions to handle data requests.
- Support table data refresh and pagination.
- Provide complete error handling and user prompts (user prompts e.g. '删除成功', '操作成功' should remain Chinese).

### 4. Code Specification
- Use TypeScript to ensure type safety.
- Follow componentization and modularization principles.
- Maintain clear and maintainable code structure.

## Precautions

### 1. Type Definition
- Create dedicated type definitions for business data.
- Ensure ProTable and ProForm use correct generic types.
- Related field type definitions are located in `@/utils/proApi/apiType.ts`. Please find the corresponding type definition based on the request function name specified by the user.
- When using interface functions, it is recommended to import and use the corresponding type definitions to get better type hints and type safety.

### 2. API Integration
- All interface functions are auto-generated by scripts and located in the `@/utils/proApi/admin.ts` directory.
- Interface function naming convention:
  - List query: `getApiV1[模块名称]Page`
  - Add: `postApiV1[模块名称]`
  - Modify: `putApiV1[模块名称]Byid`
  - Delete: `deleteApiV1[模块名称]Byids`
- Replace `[模块名称]` with the actual module name when using.
- Related field type definitions are located in `@/utils/proApi/apiType.ts`. Please find the corresponding type definition based on the interface function name.

### 3. Component Reusability
- Make full use of the features provided by ProComponent.
- Extend component configuration according to business needs.

### 4. Dictionary Configuration Explanation

#### Dictionary Type Definition
- Define dictionary types in `@/utils/proApi/types/adminTypes.ts`.
- Use `getApiV1DictBytypecodeOptions` to get dictionary options.

#### ProTable Dictionary Configuration
- Basic configuration:
  ```typescript
  {
    label: '字典字段', // UI Label
    prop: 'dictField',
    valueType: 'select',
    valueEnum: [], // Labels in here are UI, keep Chinese
    initFn: async (formItem) => {
      formItem.valueEnum = await getApiV1DictBytypecodeOptions({ typeCode: 'yourDictType' })
    }
  }
  ```
- Support for tag styles:
  ```typescript
  {
    valueEnum: [ // UI Labels
      { label: '启用', value: 1, tagType: 'success' },
      { label: '禁用', value: 0, tagType: 'info' }
    ]
  }
  ```

#### ProForm Dictionary Configuration
- Basic configuration:
  ```typescript
  {
    label: '字典字段', // UI Label
    valueType: 'select',
    prop: 'dictField',
    valueEnum: [], // Labels in here are UI, keep Chinese
    initFn: async (formItem) => {
      formItem.valueEnum = await getApiV1DictBytypecodeOptions({ typeCode: 'yourDictType' })
    },
    rules: [{ required: true, trigger: 'blur' }] // Message will be auto-generated in Chinese
  }
  ```
- Linked configuration:
  ```typescript
  {
    watch: async (value, old, formdata, formconfig, formItemTool) => {
      const [relatedField] = formItemTool.getFieldConfig(['relatedField'])
      if (value) {
        // Assuming getApiV1DictBytypecodeOptions returns labels in Chinese if that's how they are stored
        relatedField.valueEnum = await getApiV1DictBytypecodeOptions({ typeCode: value })
      }
      else {
        relatedField.valueEnum = []
      }
      // Reset related field
      if (old) formdata.relatedField = ''
    }
  }
  ```

## Custom Form Item Specification

### Using Slots to Customize Form Items

When built-in form components do not meet requirements, custom slots can be used to implement complex form items. Here are the steps to use custom slots:

#### 1. Configure Custom Form Item in column.ts

```typescript
// Configure in formColumns
{
  label: '表单项标签', // UI Label
  prop: 'fieldName',
  valueType: 'custom', // Key: set to 'custom' type
  slotName: 'customSlotName', // Define slot name
  rules: [{ required: true, message: '请输入/选择xxx', trigger: 'change' }], // Message in Chinese
}
```

#### 2. Implement Custom Slot in index.vue

```vue
<ProForm
  ref="formRef"
  v-model:open="open"
  type="drawer"
  :drawer-props="{ title: '表单标题' }" // UI Title
  :columns="formColumns"
  :on-submit="onSubmit"
>
  <!-- 自定义插槽 -->
  <template #customSlotName="scope">
    <!-- 
      scope包含以下属性：
      - formData: 整个表单数据对象
      - prop: 当前表单项的属性名
      - disabled: 表单项是否禁用
    -->
    <el-component v-model="scope.formData[scope.prop]" />
    
    <!-- 或者对于需要类型转换的情况 -->
    <el-component
      :model-value="convertValueForDisplay(scope.formData[scope.prop])"
      @update:model-value="val => scope.formData[scope.prop] = convertValueForStorage(val)"
    />
  </template>
</ProForm>
```

### Custom Form Item Examples

#### Rating Component Example

```typescript
// Configuration in column.ts
{
  label: '评分', // UI Label
  prop: 'rating',
  valueType: 'custom',
  slotName: 'ratingSlot',
  rules: [{ required: true, message: '请选择评分', trigger: 'change' }], // Message in Chinese
}
```

```vue
<!-- Implementation in index.vue -->
<ProForm
  ref="formRef"
  v-model:open="open"
  type="drawer"
  :drawer-props="{ title: '表单标题' }" // UI Title
  :columns="formColumns"
  :on-submit="onSubmit"
>
  <template #ratingSlot="scope">
    <!-- 当rating是字符串类型但组件需要数字类型时 -->
    <el-rate
      :model-value="Number(scope.formData.rating)"
      @update:model-value="val => scope.formData.rating = String(val)"
      :max="5"
    />
    
    <!-- 如果数据类型匹配，应优先使用v-model -->
    <!-- <el-rate v-model="scope.formData.rating" :max="5" /> -->
  </template>
</ProForm>
```

#### Color Picker Example

```typescript
// Configuration in column.ts
{
  label: '颜色', // UI Label
  prop: 'color',
  valueType: 'custom',
  slotName: 'colorPicker',
  rules: [{ required: true, message: '请选择颜色', trigger: 'change' }], // Message in Chinese
}
```

```vue
<!-- Implementation in index.vue -->
<template #colorPicker="scope">
  <el-color-picker v-model="scope.formData.color" show-alpha />
</template>
```

### Precautions for Custom Form Items

1.  **Data Binding**: Ensure correct binding and updating of `scope.formData[scope.prop]` value.
2.  **Type Conversion**: Perform type conversion in the slot if necessary.
3.  **Validation Rules**: Validation rules still need to be defined in the column configuration (messages in Chinese).
4.  **Naming Convention**: Slot names should be descriptive; using `fieldName + Slot` naming convention is recommended.

### Data Binding Best Practices for Custom Form Items

When performing data binding in custom form items, follow these best practices:

1.  **Prioritize v-model**: When the component supports v-model and data types match, use v-model directly for two-way binding.

```vue
<template #colorPicker="scope">
  <el-color-picker v-model="scope.formData.color" />
</template>
```

2.  **Handle Data Type Mismatches**: When the data type expected by the component differs from the data type stored in the form, use `:model-value` and `@update:model-value` for manual binding and conversion.

```vue
<template #ratingSlot="scope">
  <el-rate
    :model-value="Number(scope.formData.rating)"
    @update:model-value="val => scope.formData.rating = String(val)"
    :max="5"
  />
</template>
```

3.  **Use Computed Properties for Complex Conversions**: For situations requiring complex conversion logic, use computed properties or helper functions.

```vue
<template #customSlot="scope">
  <el-component
    :model-value="getDisplayValue(scope.formData.fieldName)"
    @update:model-value="val => updateValue(val, scope)"
  />
</template>

<script setup>
// 计算属性实现
function getDisplayValue(value) {
  // 复杂的转换逻辑
  return /* complex conversion logic involving value */ value; 
}

function updateValue(value, scope) {
  // 复杂的转换逻辑
  scope.formData[scope.prop] = /* complex conversion logic involving value */ value;
}
</script>
```

4.  **Follow Component API Design**: When using components, consult their documentation and follow recommended binding methods and property settings.

## Image Upload Configuration Specification

When image uploads are needed in a form, the following configuration specification should be used to ensure consistency and maintainability of the upload functionality.

### Standard Image Upload Configuration

```typescript
{
  label: '图片', // UI Label
  prop: 'imageUrl',
  valueType: 'upload',
  attrs: {
    limit: 1, // Limit upload quantity
    accept: 'image/*', // Limit to image uploads only
  },
  transform: (val) => {
    // 将组件数据格式转换为API所需格式
    return {
      imageUrl: val?.[0]?.url,
    }
  },
  convertValue: (val) => {
    // 将API返回的数据格式转换为组件所需格式
    if (!val) { return [] }
    return [{ url: val }]
  },
  rules: [{ required: true, trigger: 'change' }], // Message auto-generated in Chinese
  tips: '请上传图片，只支持图片格式文件', // UI Tip
}
```

### Attribute Explanation for Image Upload

- **valueType**: Must be set to 'upload', indicating the use of an upload component.
- **attrs**: Attribute configuration for the upload component.
  - **limit**: Limits the number of files to upload; typically set to 1 for single image uploads.
  - **accept**: Limits the uploaded file types; should be set to 'image/*' for image uploads.
- **transform**: Data submission transformation function, used to convert the component's internal array format to the single URL format required by the API.
- **convertValue**: Data display transformation function, used to convert the single URL format returned by the API to the array format required by the component.
- **rules**: Validation rules; it's recommended to set trigger to 'change' instead of 'blur', which is more suitable for the interaction of upload components. (Messages auto-generated in Chinese if not specified)
- **tips**: Tip text, explaining upload limits and requirements (UI, so in Chinese).

### Multiple Image Upload Configuration

When support for multiple image uploads is needed, simply adjust the `limit` attribute and data transformation functions:

```typescript
{
  label: '图片集', // UI Label
  prop: 'imageUrls',
  valueType: 'upload',
  attrs: {
    limit: 5, // 可上传多张图片
    accept: 'image/*',
  },
  transform: (val) => {
    // 将数组格式转换为逗号分隔的字符串或保持数组格式(取决于API要求)
    return {
      imageUrls: val?.map(item => item.url).join(',') // 或直接返回数组: val?.map(item => item.url)
    }
  },
  convertValue: (val) => {
    // 将API返回的格式转换回组件所需格式
    if (!val) { return [] }
    
    // 处理字符串格式
    if (typeof val === 'string') {
      return val.split(',').map(url => ({ url }))
    }
    
    // 处理数组格式
    if (Array.isArray(val)) {
      return val.map(url => ({ url }))
    }
    
    return []
  },
  rules: [{ required: true, message: '请上传图片', trigger: 'change' }], // Message in Chinese
  tips: '请上传图片集，最多支持5张图片', // UI Tip
}
```

### Upload Component Functionality Explanation

The upload component used by the system is encapsulated based on ElementPlus's upload component, with main functionalities including:

1.  **File Upload**: Supports single or multiple file uploads.
2.  **File Preview**: Supports image preview.
3.  **File Deletion**: Supports deleting uploaded files.
4.  **File Restrictions**: Supports restricting file types and sizes.

The upload component internally uses the `FileAPI.uploadOss` method to upload files to the server, returning a file URL.

### Best Practices for Image Upload

1.  **Single Image Upload**: For scenarios like avatars, cover images, etc., standard image upload configuration is recommended.
2.  **Multiple Image Upload**: For scenarios like image sets, carousels, etc., multiple image upload configuration is recommended.
3.  **Trigger Validation**: The validation trigger for upload components should be set to 'change' instead of 'blur'.
4.  **Tip Information**: Clear tips on upload limits and requirements should be provided (in Chinese for UI).
5.  **Transformation Functions**: `transform` and `convertValue` functions should be correctly implemented according to the backend API's data format requirements.
6.  **Image Dimensions**: For scenarios with special requirements for image dimensions, these should be stated in the tips (in Chinese for UI).

## Complex Form Grouping Management

When a form has many items, laying them all out flat can make the form structure complex and difficult to understand and maintain. In such cases, consider using the `group` method to logically group the form, improving readability and maintainability.

### Group Configuration Explanation

Group configuration allows related form fields to be organized together and displayed with a separator title in the UI.

#### Group Basic Structure

```typescript
{
  valueType: 'group',        // Indicates this is a group
  key: 'groupKey',           // Unique identifier for the group, used for Vue's key attribute
  attrs: {
    dividerTitle: '分组标题', // Group title displayed in the UI (Chinese)
  },
  columns: formFieldsArray,   // Array of form fields included in this group
}
```

### Implementation Steps for Grouping

1.  **Define Group Field Arrays**: Create separate field arrays for each logical group.
2.  **Configure Main Form**: Use `group` to combine the various groups.

### Complete Example of Grouping

```typescript
import type { ProFormColumn, ProTableColumn } from '@/components/ProComponent'
import type { YourModuleAddVO, YourModuleEditVO } from '@/utils/proApi/types/adminTypes'

// 基本信息分组
const basicInfoColumns: ProFormColumn<YourModuleAddVO & YourModuleEditVO>[] = [
  { label: 'ID', prop: 'id', hidden: true },
  {
    label: '名称', // UI Label
    prop: 'name',
    valueType: 'input',
    rules: [{ required: true, trigger: 'blur' }], // Message auto-generated in Chinese
  },
  // 其他基本信息字段...
]

// 详细配置分组
const detailColumns: ProFormColumn<YourModuleAddVO & YourModuleEditVO>[] = [
  {
    label: '类型', // UI Label
    prop: 'type',
    valueType: 'select',
    valueEnum: [], // Labels in here are UI, keep Chinese
    initFn: async (item) => {
      item.valueEnum = await getApiV1DictBytypecodeOptions({ typeCode: 'TypeCode' })
    },
    rules: [{ required: true, trigger: 'change' }], // Message auto-generated in Chinese
  },
  // 其他详细配置字段...
]

// Main Form Configuration
export const formColumns: ProFormColumn<YourModuleAddVO & YourModuleEditVO>[] = [
  {
    valueType: 'group',
    attrs: {
      dividerTitle: '基本信息', // UI Title (Chinese)
    },
    key: 'group1',
    columns: basicInfoColumns,
  },
  {
    valueType: 'group',
    attrs: {
      dividerTitle: '详细配置', // UI Title (Chinese)
    },
    key: 'group2',
    columns: detailColumns,
  },
]
```

### Applicable Scenarios for Grouping

In the following scenarios, using the `group` method to organize forms is recommended:

1.  **Many Fields**: When the form contains more than 10 fields.
2.  **Complex Functionality**: When the form includes multiple functional modules.
3.  **Logical Association**: When form fields have clear logical classifications.
4.  **Complex Data Structure**: When the form involves multiple data dimensions.

### Best Practices for Grouping

1.  **Reasonable Grouping**: Each group should have clear functional boundaries and internal logical connections.
2.  **Group Naming**: Group titles (UI, in Chinese) should be concise and clearly express the group's function.
3.  **Group Size**: It's recommended that each group contain 2-7 fields; too many or too few is not conducive to understanding.
4.  **Group Order**: Arrange groups in the natural order of user input, usually starting with basic information.
5.  **Type Naming**: Use meaningful names for each group's field array, such as `basicInfoColumns`, `detailSettingColumns`, etc.
6.  **Maintain Consistency**: Use the `group` method uniformly throughout the project to ensure consistent form style.
7.  **Responsive Consideration**: Ensure group titles (UI, in Chinese) remain clearly visible on different screen sizes.

### Precautions for Grouping

1.  Each group must have a unique `key` attribute for Vue's virtual DOM rendering.
2.  `dividerTitle` (UI, in Chinese) should be concise.
3.  Groups should not be excessive; it's recommended to keep them between 2-5.
4.  The use of `group` does not affect the form's data structure or submission logic.
